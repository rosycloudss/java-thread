1. 等待/通知机制
    wait(): 是当前执行代码的线程等待，将当前线程置入"预执行队列" 中，并且在wait()所在的代码行处停止执行，直到接到通知或被中断
            在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在 同步方法 或 同步代码块 中调用wait()方法。
            执行 wait()方法之后 当前线程释放锁，在从wait()返回前，线程与其他线程竞争重新获得锁
            如果调用wait()没有持有适当的锁，则会抛出 IllegalMonitorStateException，它是RuntimeException的一个子类，因此
            不需要try-catch语句进行捕捉异常

    notify(): 通知那些处于wait状态的 等待该对象的对象锁的其他线程
              在同步方法或同步代码块中调用，如果调用时线程没有持有适当的锁，就会抛出IllegalMonitorStateException
              如果有多个线程等待，则由 线程规划器 随机挑选出其中一个呈wait(Blocked)状态的线程，对其发出通知 notify， 并使它等待获取该对象
              的对象锁

              注：执行notify()方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也不会立刻获取该对象锁，要等到 调用notify()方法的
              线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取改对象锁
    notifyAll(): 通知等待队列中所用等待同一共享资源的“全部”线程从等待状态转变为可运行状态

2. 线程状态转变

    1） 创建一个新的线程对象后，调用start方法，系统为线程分配cpu资源，使其处于Runnable（与运行）状态
  
    2） 如果线程抢占到了cpu资源，线程就处于Running(运行)状态
   
    3） Runnable 状态和 Running 状态可相互切换，因为有可能线程运行一段时间后，有其他优先级更高的线程抢占了CPU资源，此时线程就
        从 Running 状态变成 Runnable 状态
        
        线程进入 Runnable 状态大体分为如下5种情况：
            调用sleep() 方法后经过的时间超过了指定的休眠时间
            线程调用的阻塞IO已经返回，阻塞方法执行完毕
            线程成功的获得了试图同步的监视器
            线程正在等待某个通知，其他线程发出通知。
            处于挂起状态的线程调用了resume恢复方法
            
    4） Blocked 是阻塞的意思，例如遇到一个IO操作，此时CPU处于空闲状态，可能会转而把cpu时间片分配给其他线程，这时也可以称为“暂停”状态。
        Blocked 状态结束后，进入Runnable状态，等待系统重新分配资源
        出现阻塞的情况大体如下5种：
           1） 线程调用sleep方法，主动放弃占用的处理器资源
           2） 线程调用了阻塞IO方法，在该方法返回前，该线程被阻塞
           3） 线程试图获得一个同步监视器，但该同步监视器正在被其他线程所持有
           4） 线程等待某个通知
           5） 线程调用了suspend方法将该线程挂起。此方法容易导致死锁，尽量避免使用该方法
    5） run() 方法运行结束后进入销毁阶段，整个线程执行完毕


    每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列，
       就绪队列存储了将要获得锁的线程
       阻塞队列存储了被阻塞的线程
     一个线程被唤醒后，才会进入就绪队列，等待cpu的调度；一个线程被wait后就会进入阻塞队列，等待下一次被唤醒
   wait() 执行后，锁自动释放
   notify() 执行后 锁不自动释放

  当线程呈wait状态时，调用线程对象的interrupt() 方法会出现 InterruptedException异常

  wait(long) ：等待某一段时间内是否有线程对锁进行唤醒，如果超过这个时间自动唤醒
  使用wait/notify模式时，当wait等待的条件发生变化时，容易造成程序逻辑的混乱

通过管道进行线程间通信
    管道流是一种特殊的流，用于在不同线程间直接传送数据，
    一个线程发送数据到输出管道中，另一个线程从输入管道中读数据
    管道类
        PipedInputStream 和 PipedOutputStream
        PipedReader 和 PipedWriter

    join(): 使所属线程的对象X正常执行run()方法，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码
    jion和synchronizd的区别
        join在内部使用wait()方法进行等待
        synchronized 关键字使用的是“对象监视器”原理作为同步

    在join过程中，如果当前线程对象被中断，则当前线程出现异常，但是调用join方法的线程依然正常运行

    join(long):设定等待的时间

    join(long) 和 sleep(long)的区别：
        join(long)的功能是在内部使用wait(long)方法来实现，所以join(long) 方法具有释放锁的特点
        sleep(long)不释放锁
